/**
 * Retypd - machine code type inference Copyright (C) 2022 GrammaTech, Inc.
 *
 * <p>This program is free software: you can redistribute it and/or modify it under the terms of the
 * GNU General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * <p>You should have received a copy of the GNU General Public License along with this program. If
 * not, see <https://www.gnu.org/licenses/>.
 */
package ghidraretypd;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import ghidra.program.model.data.Category;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.DoubleDataType;
import ghidra.program.model.data.FloatDataType;
import ghidra.program.model.data.IntegerDataType;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.data.Structure;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.data.UnsignedIntegerDataType;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionManager;
import ghidra.program.model.listing.Parameter;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Reader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This class takes care of loading the type information generated by Retypd and Ghidra's datatypes
 * and function prototypes with that information.
 */
public class RetypdTypes {

  /** Param represents a serialized function parameter. */
  class Param {
    public int index;
    public String type;
  }
  /** StructField represents a serialized field of a struct datatype. */
  class StructField {
    public String name;
    public String type;
    public long offset;
  }

  /**
   * ComplexType can represent a "function" datatype or "struct" datatype depending on the value of
   * its field `type`. This facilitates deserializing the type information into into a simple list
   * of ComplexType rather than having a more complicated Json structure.
   *
   * <p>If type is "function" the list of fields will be empty. If type is "struct" the list of
   * params and ret will be empty.
   */
  class ComplexType {
    public String type;
    public String name;
    public List<Param> params;
    public List<StructField> fields;
    public String ret;

    ComplexType() {
      // no-args constructor
    }

    /** Compute the length of the struct */
    long length(Map<String, ComplexType> allTypes) {
      StructField lastField = null;
      // Find the last field.
      for (StructField field : fields) {
        if (lastField == null || lastField.offset < field.offset) {
          lastField = field;
        }
      }
      // Compute the length of the last field.
      long lastFieldLength = 4;
      if (lastField.type.equals("float4_t")) {
        lastFieldLength = 4;
      } else if (lastField.type.equals("float8_t")) {
        lastFieldLength = 8;
      } else if (allTypes.containsKey(lastField.type)) {
        lastFieldLength = allTypes.get(lastField.type).length(allTypes);
      }
      return lastField.offset + lastFieldLength;
    }
  }

  Map<String, ComplexType> types;

  /**
   * Load a map from type names to types from a Json file specified by `typesFile`.
   *
   * @param typesFile: The path of the json file to be loaded.
   * @param out: PrintWriter to print debug information.
   * @return an object describing the type information collected from the Json file.
   */
  public static RetypdTypes loadTypes(Path typesFile, PrintWriter out) throws IOException {
    Reader reader = Files.newBufferedReader(typesFile);
    Gson gson = new Gson();
    TypeToken<List<ComplexType>> listType = new TypeToken<List<ComplexType>>() {};
    List<ComplexType> typeList = gson.fromJson(reader, listType.getType());
    Map<String, ComplexType> typeMap = new HashMap<String, ComplexType>();
    for (ComplexType typ : typeList) {
      typeMap.put(typ.name, typ);
    }

    return new RetypdTypes(typeMap);
  }

  public RetypdTypes(Map<String, ComplexType> typeMap) {
    this.types = typeMap;
  }

  /**
   * Given a datatype name, return the corresponding DataType object This can be a primitive
   * datatype, a struct datatype contained in the datatypeMap, or a pointer to a struct in the
   * datatypeMap.
   *
   * @param datatypeName: The name of the datatype.
   * @param datatypeMap: A map that contains the collection of struct datatypes keyed by their name.
   * @return The DataType corresponding to the name or null if not found.
   */
  public static DataType getDataType(
      String datatypeName, Map<String, StructureDataType> datatypeMap) {

    if (datatypeName.equals("int32_t")) {
      return IntegerDataType.dataType;
    }
    if (datatypeName.equals("uint32_t")) {
      return UnsignedIntegerDataType.dataType;
    }
    if (datatypeName.equals("float4_t")) {
      return FloatDataType.dataType;
    }
    if (datatypeName.equals("float8_t")) {
      return DoubleDataType.dataType;
    }
    if (datatypeName.startsWith("struct ")) {
      String typeName = datatypeName.substring("struct ".length());
      Boolean pointer = false;
      if (datatypeName.endsWith("*")) {
        typeName = typeName.substring(0, typeName.length() - 1);
        pointer = true;
      }
      DataType datatype = datatypeMap.get(typeName);
      if (pointer) {
        datatype = new PointerDataType(datatype);
      }
      return datatype;
    }
    return null;
  }

  /** Compute the length of a datatype. */
  public static int getDataTypeLength(DataType dataType) {
    if (dataType instanceof DoubleDataType) {
      return 8;
    }
    if (dataType instanceof StructureDataType) {
      StructureDataType struct = (StructureDataType) dataType;
      return struct.getLength();
    }
    // float, int32, and uint32.
    return 4;
  }

  /** Populate the fields of `src` int the `dest` structure datatype */
  private void updateTypeBasedOnType(Structure dest, Structure src, PrintWriter out) {
    if (dest.isNotYetDefined()) {
      // a structure that is not defined returns a getLength() of 1
      // even though the real length is 0.
      dest.growStructure(src.getLength());
    } else if (dest.getLength() < src.getLength()) {
      dest.growStructure(src.getLength() - dest.getLength());
    }
    DataTypeComponent[] srcComps = src.getDefinedComponents();
    for (DataTypeComponent comp : srcComps) {
      try {
        dest.replaceAtOffset(
            comp.getOffset(),
            comp.getDataType(),
            comp.getLength(),
            comp.getFieldName(),
            comp.getComment());
      } catch (IllegalArgumentException e) {
        out.println("Error while updating " + dest.getName() + " " + e);
      }
    }
  }

  /**
   * This method creates new datatypes and updates the function signatures based on its deserialized
   * type information. All new datatypes are created under the "retypd" category to make the easy to
   * distinguish from datatypes from other sources. This category is first removed if it already
   * exists, so calling this methods will overwrite any previous type information obtained with
   * retypd.
   */
  public void updateFunctions(
      FunctionManager funcMgr, DataTypeManager datatypeMgr, PrintWriter out) {

    Map<String, StructureDataType> datatypeMap = new HashMap<String, StructureDataType>();

    // Remove previous retypd types
    Category rootCategory = datatypeMgr.getCategory(new CategoryPath("/"));
    rootCategory.removeCategory("retypd", TaskMonitor.DUMMY);
    // Create datatypes
    for (Map.Entry<String, ComplexType> typePair : types.entrySet()) {
      ComplexType type = typePair.getValue();
      if (!type.type.equals("struct")) {
        continue;
      }
      StructureDataType struct =
          new StructureDataType(
              new CategoryPath("/retypd"), type.name, (int) type.length(types), datatypeMgr);
      datatypeMap.put(typePair.getKey(), struct);
    }

    // Populate fields
    for (Map.Entry<String, ComplexType> typePair : types.entrySet()) {
      ComplexType type = typePair.getValue();
      if (!type.type.equals("struct")) {
        continue;
      }
      StructureDataType struct = datatypeMap.get(typePair.getKey());
      for (StructField field : type.fields) {
        DataType fieldDataType = getDataType(field.type, datatypeMap);
        if (fieldDataType != null) {
          struct.replaceAtOffset(
              (int) field.offset,
              fieldDataType,
              (int) getDataTypeLength(fieldDataType),
              field.name,
              "");
        }
      }
    }

    // Update function prototypes
    for (Function func : funcMgr.getFunctions(true)) {
      String name = RetypdGenerate.fmtFunctionName(func);
      SourceType signatureSource = func.getSignatureSource();
      if (types.containsKey(name) && signatureSource != SourceType.IMPORTED) {
        out.println("Replacing type of " + name);
        ComplexType typ = types.get(name);
        Parameter[] originalParams = func.getParameters();

        // Params
        for (Param param : typ.params) {
          if (param.index >= originalParams.length) {
            continue;
          }
          DataType paramDataType = getDataType(param.type, datatypeMap);
          if (paramDataType != null) {
            try {
              // We cannot change the type of autoparameters (this)
              // but we can update it.
              if (originalParams[param.index].isAutoParameter()) {
                DataType thisParam = originalParams[param.index].getDataType();
                if (thisParam instanceof PointerDataType
                    && paramDataType instanceof PointerDataType) {
                  DataType thisObj = ((PointerDataType) thisParam).getDataType();
                  DataType paramObj = ((PointerDataType) paramDataType).getDataType();
                  if (thisObj instanceof Structure && paramObj instanceof Structure) {
                    updateTypeBasedOnType((Structure) thisObj, (Structure) paramObj, out);
                  }
                }
              } else {
                originalParams[param.index].setDataType(paramDataType, SourceType.IMPORTED);
              }
            } catch (InvalidInputException e) {
              out.print("Failed to update param " + param.index + ": ");
              out.println(e);
            }
          }
        }
        // Return type
        if (!typ.ret.equals("None")) {
          DataType retDataType = getDataType(typ.ret, datatypeMap);
          Parameter ret = func.getReturn();
          try {
            ret.setDataType(retDataType, SourceType.IMPORTED);
          } catch (InvalidInputException e) {
            out.println("Failed to update return type");
            out.println(e);
          }
        }
      }
    }
  }
}
