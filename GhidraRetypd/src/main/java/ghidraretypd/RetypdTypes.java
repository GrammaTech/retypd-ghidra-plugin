/**
 * Retypd - machine code type inference Copyright (C) 2022 GrammaTech, Inc.
 *
 * <p>This program is free software: you can redistribute it and/or modify it under the terms of the
 * GNU General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * <p>You should have received a copy of the GNU General Public License along with this program. If
 * not, see <https://www.gnu.org/licenses/>.
 */
package ghidraretypd;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import ghidra.program.model.data.BooleanDataType;
import ghidra.program.model.data.ByteDataType;
import ghidra.program.model.data.Category;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.CharDataType;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.DoubleDataType;
import ghidra.program.model.data.FloatDataType;
import ghidra.program.model.data.FunctionDefinitionDataType;
import ghidra.program.model.data.IntegerDataType;
import ghidra.program.model.data.LongDataType;
import ghidra.program.model.data.ParameterDefinition;
import ghidra.program.model.data.ParameterDefinitionImpl;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.data.ShortDataType;
import ghidra.program.model.data.SignedByteDataType;
import ghidra.program.model.data.Structure;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.data.Undefined1DataType;
import ghidra.program.model.data.Undefined2DataType;
import ghidra.program.model.data.Undefined4DataType;
import ghidra.program.model.data.Undefined8DataType;
import ghidra.program.model.data.UnsignedIntegerDataType;
import ghidra.program.model.data.UnsignedLongDataType;
import ghidra.program.model.data.UnsignedShortDataType;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionManager;
import ghidra.program.model.listing.Parameter;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.Msg;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Reader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This class takes care of loading the type information generated by Retypd and Ghidra's datatypes
 * and function prototypes with that information.
 */
public class RetypdTypes {

  /** Param represents a serialized function parameter. */
  class Param {
    public int index;
    public String type;
  }
  /** StructField represents a serialized field of a struct datatype. */
  class StructField {
    public String name;
    public String type;
    public long offset;
  }

  /** DataTypeRecord represents a pair of (Type, Size) information */
  static class DataTypeRecord {
    public int size;
    public DataType dataType;

    DataTypeRecord(int size, DataType dataType) {
      this.size = size;
      this.dataType = dataType;
    }

    /**
     * Get the size of the DataType in this record
     *
     * @return Size of the datatype
     */
    public int getSize() {
      if (size != 0) {
        return size;
      }

      return dataType.getLength();
    }
  }
  ;

  static Map<String, DataTypeRecord> retypdToDataType;

  static {
    retypdToDataType = new HashMap<String, DataTypeRecord>();
    retypdToDataType.put("int8_t", new DataTypeRecord(1, SignedByteDataType.dataType));
    retypdToDataType.put("int16_t", new DataTypeRecord(2, ShortDataType.dataType));
    retypdToDataType.put("int32_t", new DataTypeRecord(4, IntegerDataType.dataType));
    retypdToDataType.put("int64_t", new DataTypeRecord(8, LongDataType.dataType));
    retypdToDataType.put("int", new DataTypeRecord(0, IntegerDataType.dataType));

    retypdToDataType.put("uint8_t", new DataTypeRecord(1, ByteDataType.dataType));
    retypdToDataType.put("uint16_t", new DataTypeRecord(2, UnsignedShortDataType.dataType));
    retypdToDataType.put("uint32_t", new DataTypeRecord(4, UnsignedIntegerDataType.dataType));
    retypdToDataType.put("uint64_t", new DataTypeRecord(8, UnsignedLongDataType.dataType));
    retypdToDataType.put("uint", new DataTypeRecord(0, UnsignedIntegerDataType.dataType));

    retypdToDataType.put("char1_t", new DataTypeRecord(1, CharDataType.dataType));
    retypdToDataType.put("char2_t", new DataTypeRecord(2, CharDataType.dataType));
    retypdToDataType.put("char4_t", new DataTypeRecord(4, CharDataType.dataType));
    retypdToDataType.put("char8_t", new DataTypeRecord(8, CharDataType.dataType));
    retypdToDataType.put("char", new DataTypeRecord(0, CharDataType.dataType));

    retypdToDataType.put("float4_t", new DataTypeRecord(4, FloatDataType.dataType));
    retypdToDataType.put("float8_t", new DataTypeRecord(8, DoubleDataType.dataType));

    retypdToDataType.put("bool", new DataTypeRecord(0, BooleanDataType.dataType));
    retypdToDataType.put("bool4_t", new DataTypeRecord(4, BooleanDataType.dataType));

    retypdToDataType.put("char1_t[0]", new DataTypeRecord(0, Undefined1DataType.dataType));
    retypdToDataType.put("char1_t[1]", new DataTypeRecord(1, Undefined1DataType.dataType));
    retypdToDataType.put("char1_t[2]", new DataTypeRecord(2, Undefined2DataType.dataType));
    retypdToDataType.put("char1_t[4]", new DataTypeRecord(4, Undefined4DataType.dataType));
    retypdToDataType.put("char1_t[8]", new DataTypeRecord(8, Undefined8DataType.dataType));
  }

  /**
   * ComplexType can represent a "function" datatype or "struct" datatype depending on the value of
   * its field `type`. This facilitates deserializing the type information into into a simple list
   * of ComplexType rather than having a more complicated Json structure.
   *
   * <p>If type is "function" the list of fields will be empty. If type is "struct" the list of
   * params and ret will be empty.
   */
  class ComplexType {
    public String type;
    public String name;
    public List<Param> params;
    public List<StructField> fields;
    public String ret;

    ComplexType() {
      // no-args constructor
    }

    /** Compute the length of the struct */
    long length(Map<String, ComplexType> allTypes) {
      long maxLength = 1;

      // Find the last field.
      for (StructField field : fields) {
        long fieldLength = 8;

        // Compute the length of the last field.
        if (retypdToDataType.containsKey(field.type)) {
          fieldLength = retypdToDataType.get(field.type).getSize();
        } else if (allTypes.containsKey(field.type)) {
          fieldLength = allTypes.get(field.type).length(allTypes);
        }

        maxLength = Math.max(maxLength, field.offset + fieldLength);
      }

      return maxLength;
    }
  }

  Map<String, ComplexType> types;

  /**
   * Load a map from type names to types from a Json file specified by `typesFile`.
   *
   * @param typesFile: The path of the json file to be loaded.
   * @param out: PrintWriter to print debug information.
   * @return an object describing the type information collected from the Json file.
   */
  public static RetypdTypes loadTypes(Path typesFile, PrintWriter out) throws IOException {
    Reader reader = Files.newBufferedReader(typesFile);
    Gson gson = new Gson();
    TypeToken<List<ComplexType>> listType = new TypeToken<List<ComplexType>>() {};
    List<ComplexType> typeList = gson.fromJson(reader, listType.getType());
    Map<String, ComplexType> typeMap = new HashMap<String, ComplexType>();
    for (ComplexType typ : typeList) {
      typeMap.put(typ.name, typ);
    }

    return new RetypdTypes(typeMap);
  }

  public RetypdTypes(Map<String, ComplexType> typeMap) {
    this.types = typeMap;
  }

  /**
   * Given a datatype name, return the corresponding DataType object This can be a primitive
   * datatype, a struct datatype contained in the datatypeMap, or a pointer to a struct in the
   * datatypeMap.
   *
   * @param datatypeName: The name of the datatype.
   * @param datatypeMap: A map that contains the collection of struct datatypes keyed by their name.
   * @return The DataType corresponding to the name or null if not found.
   */
  public static DataTypeRecord getDataType(String datatypeName, Map<String, DataType> datatypeMap) {

    if (datatypeName.endsWith("*")) {
      String typeName = datatypeName.substring(0, datatypeName.length() - 1);
      DataTypeRecord nested = getDataType(typeName, datatypeMap);
      return new DataTypeRecord(0, new PointerDataType(nested.dataType));
    } else if (retypdToDataType.containsKey(datatypeName)) {
      return retypdToDataType.get(datatypeName);
    } else if (datatypeName.startsWith("struct ") || datatypeName.startsWith("function_")) {
      String typeName = null;

      if (datatypeName.startsWith("struct ")) {
        typeName = datatypeName.substring("struct ".length());
      } else if (datatypeName.startsWith("function_")) {
        typeName = datatypeName.substring("function_".length());
      }

      DataType datatype = datatypeMap.get(typeName);
      return new DataTypeRecord(0, datatype);
    }

    Msg.warn(null, "Unknown type name " + datatypeName);
    return null;
  }

  /** Populate the fields of `src` int the `dest` structure datatype */
  private void updateTypeBasedOnType(Structure dest, Structure src, PrintWriter out) {
    if (dest.isNotYetDefined()) {
      // a structure that is not defined returns a getLength() of 1
      // even though the real length is 0.
      dest.growStructure(src.getLength());
    } else if (dest.getLength() < src.getLength()) {
      dest.growStructure(src.getLength() - dest.getLength());
    }
    DataTypeComponent[] srcComps = src.getDefinedComponents();
    for (DataTypeComponent comp : srcComps) {
      try {
        dest.replaceAtOffset(
            comp.getOffset(),
            comp.getDataType(),
            comp.getLength(),
            comp.getFieldName(),
            comp.getComment());
      } catch (IllegalArgumentException e) {
        out.println("Error while updating " + dest.getName() + " " + e);
      }
    }
  }

  /**
   * This method creates new datatypes and updates the function signatures based on its deserialized
   * type information. All new datatypes are created under the "retypd" category to make the easy to
   * distinguish from datatypes from other sources. This category is first removed if it already
   * exists, so calling this methods will overwrite any previous type information obtained with
   * retypd.
   */
  public void updateFunctions(
      FunctionManager funcMgr, DataTypeManager datatypeMgr, PrintWriter out) {

    Map<String, DataType> datatypeMap = new HashMap<String, DataType>();

    // Remove previous retypd types
    Category rootCategory = datatypeMgr.getCategory(new CategoryPath("/"));
    rootCategory.removeCategory("retypd", TaskMonitor.DUMMY);
    // Create datatypes
    for (Map.Entry<String, ComplexType> typePair : types.entrySet()) {
      ComplexType type = typePair.getValue();
      if (type.type.equals("struct")) {
        StructureDataType struct =
            new StructureDataType(
                new CategoryPath("/retypd"), type.name, (int) type.length(types), datatypeMgr);
        datatypeMap.put(typePair.getKey(), struct);
      } else if (type.type.equals("function")) {
        FunctionDefinitionDataType func =
            new FunctionDefinitionDataType(new CategoryPath("/retypd"), type.name, datatypeMgr);
        datatypeMap.put(typePair.getKey(), func);
      }
    }

    // Populate fields
    for (Map.Entry<String, ComplexType> typePair : types.entrySet()) {
      ComplexType type = typePair.getValue();
      if (type.type.equals("struct")) {
        StructureDataType struct = (StructureDataType) datatypeMap.get(typePair.getKey());
        for (StructField field : type.fields) {
          DataTypeRecord fieldDataType = getDataType(field.type, datatypeMap);

          if (fieldDataType != null) {
            struct.replaceAtOffset(
                (int) field.offset,
                fieldDataType.dataType,
                fieldDataType.getSize(),
                field.name,
                "");
          }
        }
      } else if (type.type.equals("function")) {
        FunctionDefinitionDataType func =
            (FunctionDefinitionDataType) datatypeMap.get(typePair.getKey());

        if (!type.ret.equals("None")) {
          func.setReturnType(getDataType(type.ret, datatypeMap).dataType);
        }

        int maxIndex = 0;

        for (Param arg : type.params) {
          maxIndex = Math.max(maxIndex, arg.index);
        }

        if (maxIndex == 0) {
          continue;
        }

        ParameterDefinition[] argTypes = new ParameterDefinition[maxIndex + 1];

        for (Param arg : type.params) {
          DataTypeRecord dataType = getDataType(arg.type, datatypeMap);

          ParameterDefinitionImpl param =
              new ParameterDefinitionImpl("arg_" + arg.index, dataType.dataType, "");
          argTypes[arg.index] = param;
        }

        for (int i = 0; i < maxIndex; i++) {
          if (argTypes[i] == null) {
            ParameterDefinitionImpl param =
                new ParameterDefinitionImpl("arg_" + i, new Undefined4DataType(datatypeMgr), "");
            argTypes[i] = param;
          }
        }

        func.setArguments(argTypes);
      }
    }

    // Update function prototypes
    for (Function func : funcMgr.getFunctions(true)) {
      String name = RetypdGenerate.fmtFunctionName(func);
      SourceType signatureSource = func.getSignatureSource();
      if (types.containsKey(name) && signatureSource != SourceType.IMPORTED) {
        out.println("Replacing type of " + name);
        ComplexType typ = types.get(name);
        Parameter[] originalParams = func.getParameters();

        // Params
        for (Param param : typ.params) {
          if (param.index >= originalParams.length) {
            continue;
          }
          DataTypeRecord paramDataType = getDataType(param.type, datatypeMap);
          if (paramDataType != null) {
            try {
              // We cannot change the type of autoparameters (this)
              // but we can update it.
              if (originalParams[param.index].isAutoParameter()) {
                DataType thisParam = originalParams[param.index].getDataType();
                if (thisParam instanceof PointerDataType
                    && paramDataType.dataType instanceof PointerDataType) {
                  DataType thisObj = ((PointerDataType) thisParam).getDataType();
                  DataType paramObj = ((PointerDataType) paramDataType.dataType).getDataType();
                  if (thisObj instanceof Structure && paramObj instanceof Structure) {
                    updateTypeBasedOnType((Structure) thisObj, (Structure) paramObj, out);
                  }
                }
              } else {
                originalParams[param.index].setDataType(
                    paramDataType.dataType, SourceType.IMPORTED);
              }
            } catch (InvalidInputException e) {
              out.print("Failed to update param " + param.index + ": ");
              out.println(e);
            }
          }
        }
        // Return type
        if (!typ.ret.equals("None")) {
          DataTypeRecord retDataType = getDataType(typ.ret, datatypeMap);
          Parameter ret = func.getReturn();
          try {
            ret.setDataType(retDataType.dataType, SourceType.IMPORTED);
          } catch (InvalidInputException e) {
            out.println("Failed to update return type");
            out.println(e);
          }
        }
      }
    }
  }
}
